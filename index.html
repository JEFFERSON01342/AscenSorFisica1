<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simulador de Ascensor Manual — Mejorado</title>
  <style>
    :root{--card:#fff;--muted:#666;--accent:#0b63d6}
    body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial;margin:0;background:#f3f4f6;color:#111}
    .container{max-width:1100px;margin:22px auto;padding:18px}
    .grid{display:grid;grid-template-columns:1fr 460px 380px;gap:16px}
    .card{background:var(--card);padding:12px;border-radius:12px;box-shadow:0 6px 18px rgba(17,24,39,0.06)}
    label{font-size:12px;color:var(--muted);display:block;margin-top:10px}
    input[type=number],select{width:100%;padding:8px;border-radius:8px;border:1px solid #d1d5db}
    button{padding:8px 12px;border-radius:8px;border:0;background:var(--accent);color:white;cursor:pointer}
    button.secondary{background:#efefef;color:#111}
    .small{font-size:13px;color:var(--muted)}
    .results{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-top:8px}
    .result{background:#fbfbfb;padding:8px;border-radius:8px;font-family:monospace}
    .svgwrap{background:linear-gradient(180deg,#fff,#f8fafc);display:flex;align-items:center;justify-content:center;padding:12px;border-radius:8px}
    footer{margin-top:14px;color:var(--muted);font-size:13px}
    .note{font-size:13px;color:#444}
    @media (max-width:1100px){.grid{grid-template-columns:1fr}} 
  </style>
</head>
<body>
  <div class="container">
    <h1 style="margin:0 0 6px 0">Simulador de Ascensor Manual — Mejorado</h1>
    <p class="small">Versión mejorada: fórmulas revisadas y visualización ampliada (dadle <strong>Simular</strong>).</p>

    <div class="grid">
      <!-- Controls -->
      <div class="card">
        <h3 style="margin:0 0 6px 0">Parámetros</h3>
        <label>Masa cabina m (kg)</label>
        <input id="m" type="number" value="200" step="1" />

        <label>Número de ramales n</label>
        <input id="n" type="number" value="2" min="1" step="1" />

        <label>Radio tambor r (m)</label>
        <input id="r" type="number" value="0.2" step="0.01" />

        <label>Radio manivela L_h (m)</label>
        <input id="Lh" type="number" value="0.5" step="0.01" />

        <label>Momento de inercia tambor I (kg·m²)</label>
        <input id="I" type="number" value="5" step="0.1" />

        <label>Gravedad g (m/s²)</label>
        <input id="g" type="number" value="9.8" step="0.01" />

        <label>Aceleración de la cabina a (m/s²) (positiva hacia arriba)</label>
        <input id="a" type="number" value="0.5" step="0.01" />

        <label>Tiempo de aceleración t (s)</label>
        <input id="tSim" type="number" value="2" step="0.1" />

        <div style="margin-top:12px;display:flex;gap:8px">
          <button id="btnSim">Simular</button>
          <button id="btnReset" class="secondary">Reset</button>
        </div>

        <div class="small" style="margin-top:10px">Notas: (1) La relación entre velocidad lineal de la cabina y velocidad angular del tambor es <strong>v = r·ω / n</strong>. (2) La masa equivalente debida al tambor es <strong>m<sub>eq, tambor</sub> = I·n² / r²</strong>.</div>
      </div>

      <!-- Visual -->
      <div class="card svgwrap" style="flex-direction:column">
        <h3 style="margin:0 0 8px 0">Vista mecánica</h3>
        <svg id="scene" width="420" height="360" viewBox="0 0 420 360"></svg>
        <div style="display:flex;gap:12px;align-items:center;margin-top:8px;width:100%;justify-content:space-between">
          <div class="small" id="tNow">Tiempo: 0.00 s</div>
          <div class="note">Ángulo manivela: <span id="angleDisplay">0.00</span> rad</div>
        </div>
      </div>

      <!-- Results -->
      <div class="card">
        <h3 style="margin:0 0 6px 0">Resultados (física y energía)</h3>
        <div id="resultsGrid" class="results"></div>
        <div style="margin-top:10px" class="small">Comprobación: W_in debe igualar (ΔK + ΔU + pérdidas). Esta versión asume <strong>sin pérdidas</strong> si el coeficiente de fricción es 0.</div>
      </div>
    </div>

    <footer>Si quieres, después agrego fricción variable y gráficos (energía vs tiempo) — dime.</footer>
  </div>

  <script>
    // --- Utilidades ---
    function num(id){const v=parseFloat(document.getElementById(id).value);return isNaN(v)?0:v}

    // --- Física corregida ---
    function computeAll({m,n,r,Lh,I,g,a,t}){
      // Estática
      const T1_static = (m * g) / n;                    // T = mg / n
      const tau_static = T1_static * r;                 // τ = T r
      const Fh_static = tau_static / Lh;                // F_h = τ / L_h

      // Dinámica (ecuaciones correctas):
      // n T1 - m g = m a  => T1 = m(g+a)/n
      // τ_h - T1 r = I α  and α = n a / r
      const T1_dyn = (m * (g + a)) / n;
      const alpha = (n * a) / r; // α
      const tau_dyn = I * alpha + T1_dyn * r; // τ_h = I α + T1 r
      const Fh_dyn = tau_dyn / Lh;

      // Velocidades y desplazamientos
      const v_after = a * t;                    // v = a t
      const omega_after = (v_after * n) / r;    // ω = v n / r
      const dh = 0.5 * a * t * t;               // Δh
      const s_cuerda = n * dh;

      // Energías con masa equivalente correcta
      // K_cab = 1/2 m v^2
      // K_tamb = 1/2 I ω^2 = 1/2 (I n^2 / r^2) v^2 => equivalente m_tamb = I n^2 / r^2
      const K_cab = 0.5 * m * v_after * v_after;
      const K_tamb = 0.5 * I * omega_after * omega_after;
      const U = m * g * dh;

      // Trabajo: θ = 0.5 α t^2, W_in = τ_h θ
      const theta = 0.5 * alpha * t * t;
      const W_in = tau_dyn * theta;
      const W_out = U; // cambio en energía potencial

      // Masa equivalente total (para energía cinética total expresada como 1/2 m_eq v^2)
      const m_tamb_eq = I * (n * n) / (r * r); // I n^2 / r^2
      const m_eq_total = m + m_tamb_eq;

      return {
        T1_static, tau_static, Fh_static,
        T1_dyn, alpha, tau_dyn, Fh_dyn,
        v_after, omega_after, dh, s_cuerda,
        K_cab, K_tamb, U, theta, W_in, W_out,
        m_tamb_eq, m_eq_total
      };
    }

    // --- SVG drawing ---
    const svg = document.getElementById('scene');
    const W = 420, H = 360;
    const drumX = 80, drumY = 60; // tambor superior izquierdo
    const manivelaX = 340, manivelaY = 220;
    const cabinBaseY = 260; // y pixel when h=0
    const scale = 60; // px per meter

    function clearSVG(){while(svg.firstChild) svg.removeChild(svg.firstChild)}

    function drawScene(n, dh_now, results, angleManivela){
      clearSVG();
      // soporte superior central
      const support = el('rect',{x:drumX-10,y:drumY-20,width:20,height:40,rx:3,fill:'#333'});svg.appendChild(support);
      // tambor (drum)
      svg.appendChild(el('circle',{cx:drumX,cy:drumY,r:22,stroke:'#444','stroke-width':4,fill:'#eee'}));
      // tambor eje
      svg.appendChild(el('rect',{x:drumX-4,y:drumY-26,width:8,height:52,fill:'#bbb'}));

      // polea superior (distinta del tambor) para mostrar polipasto visualmente
      const topPulleyX = drumX + 40; const topPulleyY = drumY;
      svg.appendChild(el('circle',{cx:topPulleyX,cy:topPulleyY,r:16,stroke:'#666','stroke-width':3,fill:'#fafafa'}));

      // Dibujar manivela (en el lado derecho) con brazo giratorio
      svg.appendChild(el('circle',{cx:manivelaX,cy:manivelaY,r:30,stroke:'#333','stroke-width':3,fill:'#fff'}));
      // brazo manivela
      const armLen = 42;
      const armX = manivelaX + armLen * Math.cos(angleManivela);
      const armY = manivelaY + armLen * Math.sin(angleManivela);
      svg.appendChild(el('line',{x1:manivelaX,y1:manivelaY,x2:armX,y2:armY,stroke:'#111','stroke-width':4,'stroke-linecap':'round'}));
      svg.appendChild(el('circle',{cx:armX,cy:armY,r:6,fill:'#111'}));

      // Cables: representar n ramales que van desde topPulley hasta la cabina
      const cabinYPixel = cabinBaseY - dh_now * scale;
      for(let i=0;i<n;i++){
        const offset = (i - (n-1)/2) * 10;
        // del tambor al topPulley (visual) - mostrar cuerda desde tambor hacia la polea superior
        svg.appendChild(el('line',{x1:drumX+20,y1:drumY,x2:topPulleyX-16,y2:topPulleyY,stroke:'#222','stroke-width':2}));
        // de polea superior a la cabina
        svg.appendChild(el('line',{x1:topPulleyX+offset,y1:topPulleyY+12,x2:drumX+offset,y2:cabinYPixel-18,stroke:'#222','stroke-width':2}));
      }

      // Cabina (rect)
      svg.appendChild(el('rect',{x:drumX-40,y:cabinYPixel-30,width:160,height:60,rx:8,fill:'#f3f4f6',stroke:'#111'}));
      svg.appendChild(el('text',{x:drumX+40,y:cabinYPixel, 'text-anchor':'middle', 'dominant-baseline':'middle','font-size':14, fill:'#111'}, 'Cabina'));

      // Ground
      svg.appendChild(el('line',{x1:0,y1:cabinBaseY+40,x2:W,y2:cabinBaseY+40,stroke:'#999','stroke-dasharray':'4 4'}));

      // Overlay numbers
      svg.appendChild(el('text',{x:210,y:30,'font-size':13,fill:'#111'}, `v=${results.v_after.toFixed(3)} m/s`));
      svg.appendChild(el('text',{x:210,y:50,'font-size':13,fill:'#111'}, `ω=${results.omega_after.toFixed(3)} rad/s`));
      svg.appendChild(el('text',{x:210,y:70,'font-size':13,fill:'#111'}, `Δh=${results.dh.toFixed(3)} m`));
      svg.appendChild(el('text',{x:210,y:90,'font-size':13,fill:'#111'}, `m_eq tambor = ${results.m_tamb_eq.toFixed(2)} kg`));
    }

    function el(tag, attrs, txt){ const e = document.createElementNS('http://www.w3.org/2000/svg', tag); if(attrs) for(const k in attrs) e.setAttribute(k, attrs[k]); if(txt) e.textContent = txt; return e; }

    // --- Simulación ---
    let raf=null; let start=null; let running=false; let simParams=null; let simResults=null;

    function startSim(){
      if(running) return; // evitar duplicados
      const params = {
        m: num('m'), n: Math.max(1, Math.floor(num('n'))), r: num('r'), Lh: num('Lh'), I: num('I'), g: num('g'), a: num('a'), t: num('tSim')
      };
      simParams = params;
      simResults = computeAll(params);
      running = true; start = null; cancelAnimationFrame(raf); raf = requestAnimationFrame(loop);
    }

    function resetSim(){ running=false; cancelAnimationFrame(raf); start=null; simParams=null; simResults=null; document.getElementById('tNow').textContent='Tiempo: 0.00 s'; document.getElementById('angleDisplay').textContent='0.00'; const r0 = Math.max(1, Math.floor(num('n'))); drawScene(r0,0,computeAll({m:num('m'),n:r0,r:num('r'),Lh:num('Lh'),I:num('I'),g:num('g'),a:num('a'),t:num('tSim')}),0); renderResults(computeAll({m:num('m'),n:r0,r:num('r'),Lh:num('Lh'),I:num('I'),g:num('g'),a:num('a'),t:num('tSim')})); }

    function loop(ts){ if(!start) start = ts; const elapsed=(ts-start)/1000; const tNow = Math.min(elapsed, simParams.t); document.getElementById('tNow').textContent = 'Tiempo: ' + tNow.toFixed(2) + ' s';
      // Cinemática: dh = 0.5 a t^2
      const dh_now = 0.5 * simParams.a * tNow * tNow;
      // ángulo manivela: θ(t) = 0.5 α t^2  where α = n a / r
      const alpha = (simParams.n * simParams.a) / simParams.r;
      const theta_now = 0.5 * alpha * tNow * tNow;
      document.getElementById('angleDisplay').textContent = theta_now.toFixed(3);
      // dibujar
      drawScene(simParams.n, dh_now, simResults, theta_now);
      if(elapsed < simParams.t) raf = requestAnimationFrame(loop); else { running=false; cancelAnimationFrame(raf); renderResults(simResults); }
    }

    // --- Mostrar resultados en la UI ---
    function renderResults(r){
      const grid = document.getElementById('resultsGrid'); grid.innerHTML='';
      const rows = [
        ['Tensión (estática) T₁', r.T1_static.toFixed(2)+' N'],
        ['Torque (estático) τ', r.tau_static.toFixed(2)+' N·m'],
        ['Fuerza humana (estática) F_h', r.Fh_static.toFixed(2)+' N'],

        ['Tensión (dinámica) T₁', r.T1_dyn.toFixed(2)+' N'],
        ['α (rad/s²)', r.alpha.toFixed(3)+' rad/s²'],
        ['Torque (dinámico) τ', r.tau_dyn.toFixed(2)+' N·m'],
        ['Fuerza humana (dinámica) F_h', r.Fh_dyn.toFixed(2)+' N'],

        ['Vel. final v', r.v_after.toFixed(3)+' m/s'],
        ['Vel. ang. ω', r.omega_after.toFixed(3)+' rad/s'],

        ['K cabina', r.K_cab.toFixed(2)+' J'],
        ['K tambor', r.K_tamb.toFixed(2)+' J'],
        ['ΔU (potencial)', r.U.toFixed(2)+' J'],

        ['Trabajo W_in', r.W_in.toFixed(2)+' J'],
        ['Trabajo útil W_out (ΔU)', r.W_out.toFixed(2)+' J']
      ];
      for(const [k,v] of rows){ const d = document.createElement('div'); d.className='result'; d.innerHTML = `<div style="font-size:12px;color:#666">${k}</div><div style="margin-top:6px">${v}</div>`; grid.appendChild(d);} 
      const check = document.createElement('div'); check.className='result'; check.style.gridColumn='1 / -1'; check.innerHTML = `<div style="font-size:12px;color:#666">Comprobación (W_in ?= K_cab + K_tamb + ΔU)</div><div style="margin-top:6px">W_in = ${r.W_in.toFixed(2)} J • (K+U) = ${(r.K_cab + r.K_tamb + r.U).toFixed(2)} J</div>`; grid.appendChild(check);
      const meq = document.createElement('div'); meq.className='result'; meq.style.gridColumn='1 / -1'; meq.innerHTML = `<div style="font-size:12px;color:#666">Masa equivalente del tambor</div><div style="margin-top:6px">m_tamb_eq = I·n² / r² = ${r.m_tamb_eq.toFixed(3)} kg — m_eq total = ${r.m_eq_total.toFixed(3)} kg</div>`; grid.appendChild(meq);
    }

    // wire buttons
    document.getElementById('btnSim').addEventListener('click', ()=>{ startSim(); });
    document.getElementById('btnReset').addEventListener('click', ()=>{ resetSim(); });

    // inicial
    resetSim();

    // actualizar resultados cuando cambien inputs (si no está corriendo)
    const ids = ['m','n','r','Lh','I','g','a','tSim']; ids.forEach(id=>document.getElementById(id).addEventListener('input', ()=>{ if(!running) renderResults(computeAll({m:num('m'),n:Math.max(1,Math.floor(num('n'))),r:num('r'),Lh:num('Lh'),I:num('I'),g:num('g'),a:num('a'),t:num('tSim')})); }));

  </script>
</body>
</html>
