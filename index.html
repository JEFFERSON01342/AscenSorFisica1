<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simulador de Ascensor Manual — Avanzado (fricción, gráficos, anim)</title>
  <style>
    :root{--card:#fff;--muted:#666;--accent:#0b63d6}
    body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial;margin:0;background:#f3f4f6;color:#111}
    .container{max-width:1200px;margin:20px auto;padding:18px}
    .grid{display:grid;grid-template-columns:1fr 520px 360px;gap:16px}
    .card{background:var(--card);padding:12px;border-radius:12px;box-shadow:0 6px 18px rgba(17,24,39,0.06)}
    label{font-size:12px;color:var(--muted);display:block;margin-top:10px}
    input[type=number],select{width:100%;padding:8px;border-radius:8px;border:1px solid #d1d5db}
    button{padding:8px 12px;border-radius:8px;border:0;background:var(--accent);color:white;cursor:pointer}
    button.secondary{background:#efefef;color:#111}
    .small{font-size:13px;color:var(--muted)}
    .results{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-top:8px}
    .result{background:#fbfbfb;padding:8px;border-radius:8px;font-family:monospace}
    .svgwrap{background:linear-gradient(180deg,#fff,#f8fafc);display:flex;align-items:center;justify-content:center;padding:12px;border-radius:8px}
    .graph{background:#fff;border-radius:8px;padding:8px;margin-top:8px}
    footer{margin-top:14px;color:var(--muted);font-size:13px}
    @media (max-width:1100px){.grid{grid-template-columns:1fr}} 
  </style>
</head>
<body>
  <div class="container">
    <h1 style="margin:0 0 6px 0">Simulador de Ascensor Manual — Avanzado</h1>
    <p class="small">Incluye: fricción constante (τ_f), gráficos en tiempo real (energía y altura) y animación mejorada (cuerda enrollándose, poleas).</p>

    <div class="grid">
      <!-- Controls -->
      <div class="card">
        <h3 style="margin:0 0 6px 0">Parámetros</h3>
        <label>Masa cabina m (kg)</label>
        <input id="m" type="number" value="200" step="1" />

        <label>Número de ramales n</label>
        <input id="n" type="number" value="2" min="1" step="1" />

        <label>Radio tambor r (m)</label>
        <input id="r" type="number" value="0.2" step="0.01" />

        <label>Radio manivela L_h (m)</label>
        <input id="Lh" type="number" value="0.5" step="0.01" />

        <label>Momento de inercia tambor I (kg·m²)</label>
        <input id="I" type="number" value="5" step="0.1" />

        <label>Gravedad g (m/s²)</label>
        <input id="g" type="number" value="9.8" step="0.01" />

        <label>Aceleración deseada de la cabina a (m/s²) (positiva hacia arriba)</label>
        <input id="a" type="number" value="0.5" step="0.01" />

        <label>Tiempo de aceleración t (s)</label>
        <input id="tSim" type="number" value="2" step="0.1" />

        <label>Torque de fricción (τ_f) constante (N·m) — opción A</label>
        <input id="tau_f" type="number" value="10" step="0.1" />

        <div style="margin-top:12px;display:flex;flex-wrap:wrap;gap:8px">
          <button id="btnSim">Simular</button>
          <button id="btnPause" class="secondary">Pausa</button>
          <button id="btnReset" class="secondary">Reset</button>
          <button id="btnStatic" class="secondary">Estático</button>
        </div>

        <div class="small" style="margin-top:10px">La fricción τ_f se resta como torque adicional constante: W_pérdida = τ_f · θ. Los gráficos actualizan en tiempo real.</div>
      </div>

      <!-- Visual -->
      <div class="card svgwrap" style="flex-direction:column">
        <h3 style="margin:0 0 8px 0">Vista mecánica</h3>
        <svg id="scene" width="500" height="420" viewBox="0 0 500 420"></svg>
        <div style="display:flex;gap:12px;align-items:center;margin-top:8px;width:100%;justify-content:space-between">
          <div class="small" id="tNow">Tiempo: 0.00 s</div>
          <div class="note">Ángulo manivela: <span id="angleDisplay">0.00</span> rad</div>
        </div>

        <div class="graph" style="width:100%;display:flex;gap:8px">
          <canvas id="graphEnergy" width="320" height="120" style="border-radius:6px;background:#fafafa"></canvas>
          <canvas id="graphHeight" width="320" height="120" style="border-radius:6px;background:#fafafa"></canvas>
        </div>
      </div>

      <!-- Results -->
      <div class="card">
        <h3 style="margin:0 0 6px 0">Resultados (física y energía)</h3>
        <div id="resultsGrid" class="results"></div>
        <div style="margin-top:10px" class="small">Comprobación: W_in = ∫ τ_h ω dt, pérdidas = τ_f θ. Esta versión calcula todo numéricamente en pequeños pasos dt.</div>
      </div>
    </div>

    <footer>Derechos reservados © Jefferson, Michel, Fernando, Ángel, Daniela.</footer>
  </div>

  <script>
    const el = id => document.getElementById(id);
    const num = id => { const v = parseFloat(el(id).value); return isNaN(v)?0:v };

    function nominalValues(params){
      const {m,n,r,Lh,I,g,a} = params;
      const T1_static = (m*g)/n;
      const tau_static = T1_static * r;
      const Fh_static = tau_static / Lh;

      const T1_dyn = (m*(g+a))/n;
      const alpha = (n*a)/r;
      const tau_dyn = I*alpha + T1_dyn * r;
      const Fh_dyn = tau_dyn / Lh;

      return {T1_static,tau_static,Fh_static,T1_dyn,alpha,tau_dyn,Fh_dyn};
    }

    const svg = document.getElementById('scene');
    const W = 500, H = 420;
    const drumX = 100, drumY = 80;
    const manivelaX = 420, manivelaY = 260;
    const cabinBaseY = 320;
    const scale = 60;

    function clearSVG(){ while(svg.firstChild) svg.removeChild(svg.firstChild); }

    function drawScene(n, dh_now, simState, staticMode=false){
      clearSVG();
      svg.appendChild(sv('rect',{x:drumX-12,y:drumY-24,width:24,height:48,rx:4,fill:'#333'}));
      svg.appendChild(sv('circle',{cx:drumX,cy:drumY,r:26,stroke:'#444','stroke-width':4,fill:'#eee'}));
      svg.appendChild(sv('rect',{x:drumX-6,y:drumY-30,width:12,height:60,fill:'#bbb'}));

      const topPulleyX = drumX + 60, topPulleyY = drumY;
      svg.appendChild(sv('circle',{cx:topPulleyX,cy:topPulleyY,r:18,stroke:'#666','stroke-width':3,fill:'#fafafa'}));
      svg.appendChild(sv('circle',{cx:topPulleyX,cy:topPulleyY,r:6,fill:'#999'}));

      svg.appendChild(sv('circle',{cx:manivelaX,cy:manivelaY,r:36,stroke:'#333','stroke-width':3,fill:'#fff'}));
      const armLen = 48;
      const angle = simState.theta;
      const armX = manivelaX + armLen * Math.cos(angle);
      const armY = manivelaY + armLen * Math.sin(angle);
      svg.appendChild(sv('line',{x1:manivelaX,y1:manivelaY,x2:armX,y2:armY,stroke:'#111','stroke-width':5,'stroke-linecap':'round'}));
      svg.appendChild(sv('circle',{cx:armX,cy:armY,r:7,fill:'#111'}));

      svg.appendChild(sv('line',{x1:drumX+26,y1:drumY,x2:topPulleyX-18,y2:topPulleyY,stroke:'#222','stroke-width':2}));

      const cabinYPixel = cabinBaseY - dh_now*scale;
      for(let i=0;i<n;i++){
        const offset = (i - (n-1)/2) * 12;
        const color = staticMode ? '#5b7bb0' : '#222';
        const line = sv('line',{x1:topPulleyX+offset,y1:topPulleyY+18,x2:drumX+offset,y2:cabinYPixel-30,stroke:color,'stroke-width':Math.min(6,1+simState.T1/400)});
        svg.appendChild(line);
      }

      svg.appendChild(sv('rect',{x:drumX-40,y:cabinYPixel-30,width:180,height:60,rx:10,fill:'#f3f4f6',stroke:'#111'}));
      svg.appendChild(sv('text',{x:drumX+50,y:cabinYPixel,'text-anchor':'middle','dominant-baseline':'middle','font-size':14,fill:'#111'}, 'Cabina'));

      svg.appendChild(sv('text',{x:topPulleyX+80,y:drumY-10,'font-size':12,fill:'#111'}, `T1=${simState.T1.toFixed(1)} N`));
      svg.appendChild(sv('text',{x:topPulleyX+80,y:drumY+8,'font-size':12,fill:'#111'}, `τ_f=${simState.tau_f.toFixed(2)} N·m`));

      svg.appendChild(sv('line',{x1:0,y1:cabinBaseY+48,x2:W,y2:cabinBaseY+48,stroke:'#999','stroke-dasharray':'4 4'}));
    }

    function sv(tag, attrs, txt){ const n = document.createElementNS('http://www.w3.org/2000/svg', tag); if(attrs) for(const k in attrs) n.setAttribute(k, attrs[k]); if(txt) n.textContent = txt; return n }

    // --- Simulación dinámica ---
    let raf=null; let start=0; let running=false; let paused=false;
    let simData = {time:[], energyIn:[], energyK:[], energyU:[], height:[], T1:[]};

    function simulateStart(){ if(running) return; paused=false; running=true; simData = {time:[], energyIn:[], energyK:[], energyU:[], height:[], T1:[]}; start = null; cancelAnimationFrame(raf); raf = requestAnimationFrame(step); }
    function simulatePause(){ paused = !paused; }
    function simulateReset(){ running=false; paused=false; cancelAnimationFrame(raf); start=null; simData = {time:[], energyIn:[], energyK:[], energyU:[], height:[], T1:[]}; renderInitial(); }

    function step(ts){
      if(!start) start = ts; if(paused){ raf = requestAnimationFrame(step); return; }
      const elapsed = (ts-start)/1000; const params = {m:num('m'), n: Math.max(1,Math.floor(num('n'))), r:num('r'), Lh:num('Lh'), I:num('I'), g:num('g'), a:num('a'), t:num('tSim'), tau_f:num('tau_f')};
      const tEnd = params.t;
      const tNow = Math.min(elapsed, tEnd);
      const dh = 0.5 * params.a * tNow * tNow;
      const v = params.a * tNow;
      const omega = (v * params.n) / params.r;
      const alpha = (params.n * params.a) / params.r;
      const theta = 0.5 * alpha * tNow * tNow;

      const T1 = (params.m * (params.g + params.a)) / params.n;
      const tau_needed = params.I * alpha + T1 * params.r;
      const tau_h = tau_needed + params.tau_f;

      simData.time.push(tNow);
      const K_cab = 0.5 * params.m * v * v;
      const K_tamb = 0.5 * params.I * omega * omega;
      const U = params.m * params.g * dh;
      simData.energyK.push(K_cab + K_tamb);
      simData.energyU.push(U);
      const lastIndex = simData.time.length - 1;
      if(lastIndex === 0){ simData.energyIn.push(0); } else {
        const dt = simData.time[lastIndex] - simData.time[lastIndex-1];
        const tPrev = simData.time[lastIndex-1];
        const vPrev = params.a * tPrev; const omegaPrev = (vPrev * params.n) / params.r;
        const tau_hPrev = (params.I * alpha + (params.m*(params.g+params.a))/params.n*params.r) + params.tau_f;
        const Pprev = tau_hPrev * omegaPrev; const Pnow = tau_h * omega;
        const Wprev = simData.energyIn[lastIndex-1] || 0;
        simData.energyIn.push(Wprev + 0.5 * (Pprev + Pnow) * dt);
      }

      simData.height.push(dh);
      simData.T1.push(T1);

      el('tNow').textContent = 'Tiempo: ' + tNow.toFixed(2) + ' s';
      const simState = {T1: T1, tau_f: params.tau_f, theta: theta};
      drawScene(params.n, dh, simState);
      el('angleDisplay').textContent = theta.toFixed(3);
      drawGraphs(simData);
      if(elapsed < tEnd){ raf = requestAnimationFrame(step); } else { running=false; cancelAnimationFrame(raf); renderFinalResults(params, simData); }
    }

    // --- NUEVO: Modo estático ---
    function simulateStatic() {
      const params = {
        m: num('m'),
        n: Math.max(1, Math.floor(num('n'))),
        r: num('r'),
        Lh: num('Lh'),
        I: num('I'),
        g: num('g')
      };

      const T1_static = (params.m * params.g) / params.n;
      const tau_static = T1_static * params.r;
      const Fh_static = tau_static / params.Lh;
      const tau_f = num('tau_f');

      const simState = { T1: T1_static, tau_f: tau_f, theta: 0 };
      drawScene(params.n, 0, simState, true);

      const grid = el('resultsGrid'); 
      grid.innerHTML = '';
      const rows = [
        ['Tensión (estática) T₁', T1_static.toFixed(2)+' N'],
        ['Torque (estático) τ', tau_static.toFixed(2)+' N·m'],
        ['Fuerza humana (estática) Fₕ', Fh_static.toFixed(2)+' N'],
        ['Fricción τ_f', tau_f.toFixed(2)+' N·m'],
        ['Trabajo perdido (si gira 1 vuelta)', (tau_f*2*Math.PI).toFixed(2)+' J']
      ];
      for (const [k, v] of rows) {
        const d = document.createElement('div');
        d.className = 'result';
        d.innerHTML = `<div style="font-size:12px;color:#666">${k}</div><div style="margin-top:6px">${v}</div>`;
        grid.appendChild(d);
      }

      el('tNow').textContent = 'Tiempo: 0.00 s (estático)';
      el('angleDisplay').textContent = '0.00';
    }

    function drawGraphs(data){
      const ctxE = document.getElementById('graphEnergy').getContext('2d');
      const ctxH = document.getElementById('graphHeight').getContext('2d');
      const times = data.time;
      const Wins = data.energyIn;
      const Ktot = data.energyK;
      const U = data.energyU;
      if(times.length < 2){ ctxE.clearRect(0,0,320,120); ctxH.clearRect(0,0,320,120); return; }
      function drawLine(ctx, arr, color){ ctx.beginPath(); arr.forEach((v,i)=>{ const x=i/(arr.length-1)*320; const y=120 - (v/Math.max(...arr))*120; if(i==0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }); ctx.strokeStyle=color; ctx.lineWidth=2; ctx.stroke(); }
      ctxE.clearRect(0,0,320,120);
      drawLine(ctxE, Wins, '#0b63d6');
      drawLine(ctxE, Ktot, '#f87171');
      drawLine(ctxE, U, '#10b981');
      ctxH.clearRect(0,0,320,120);
      drawLine(ctxH, data.height, '#0ea5e9');
    }

    function renderFinalResults(params, data){
      const grid = el('resultsGrid'); grid.innerHTML = '';
      const W_in = data.energyIn.at(-1); const E_k = data.energyK.at(-1); const E_u = data.energyU.at(-1);
      const losses = W_in - (E_k + E_u);
      const nominal = nominalValues(params);
      const rows = [
        ['Tensión (dinámica) T₁', nominal.T1_dyn.toFixed(2)+' N'],
        ['Torque total τ_h', nominal.tau_dyn.toFixed(2)+' N·m'],
        ['Fuerza humana Fₕ', nominal.Fh_dyn.toFixed(2)+' N'],
        ['Altura final Δh', data.height.at(-1).toFixed(3)+' m'],
        ['Energía cinética + potencial', (E_k+E_u).toFixed(2)+' J'],
        ['Trabajo de entrada', W_in.toFixed(2)+' J'],
        ['Pérdidas (fricción)', losses.toFixed(2)+' J']
      ];
      for(const [k,v] of rows){ const d=document.createElement('div'); d.className='result'; d.innerHTML=`<div style="font-size:12px;color:#666">${k}</div><div style="margin-top:6px">${v}</div>`; grid.appendChild(d); }
    }

    function renderInitial(){
      const params = {m:num('m'),n:Math.max(1,Math.floor(num('n'))),r:num('r'),Lh:num('Lh'),I:num('I'),g:num('g'),a:num('a')};
      const nominal = nominalValues(params);
      const grid = el('resultsGrid'); grid.innerHTML = '';
      const rows = [
        ['Tensión (estática) T₁', nominal.T1_static.toFixed(2)+' N'],
        ['Torque (estático) τ', nominal.tau_static.toFixed(2)+' N·m'],
        ['Fuerza humana (estática) Fₕ', nominal.Fh_static.toFixed(2)+' N']
      ];
      for(const [k,v] of rows){ const d=document.createElement('div'); d.className='result'; d.innerHTML=`<div style="font-size:12px;color:#666">${k}</div><div style="margin-top:6px">${v}</div>`; grid.appendChild(d); }
      const simState = {T1: nominal.T1_static, tau_f: num('tau_f'), theta:0};
      drawScene(params.n, 0, simState);
      drawGraphs({time:[],energyIn:[],energyK:[],energyU:[],height:[]});
      el('angleDisplay').textContent='0.00';
    }

    el('btnSim').onclick=simulateStart;
    el('btnPause').onclick=simulatePause;
    el('btnReset').onclick=simulateReset;
    el('btnStatic').onclick=simulateStatic;
    renderInitial();
  </script>
</body>
</html>

