<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simulador de Ascensor Manual — Avanzado (fricción, gráficos, anim)</title>
  <style>
    :root{--card:#fff;--muted:#666;--accent:#0b63d6}
    body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial;margin:0;background:#f3f4f6;color:#111}
    .container{max-width:1200px;margin:20px auto;padding:18px}
    .grid{display:grid;grid-template-columns:1fr 520px 360px;gap:16px}
    .card{background:var(--card);padding:12px;border-radius:12px;box-shadow:0 6px 18px rgba(17,24,39,0.06)}
    label{font-size:12px;color:var(--muted);display:block;margin-top:10px}
    input[type=number],select{width:100%;padding:8px;border-radius:8px;border:1px solid #d1d5db}
    button{padding:8px 12px;border-radius:8px;border:0;background:var(--accent);color:white;cursor:pointer}
    button.secondary{background:#efefef;color:#111}
    .small{font-size:13px;color:var(--muted)}
    .results{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-top:8px}
    .result{background:#fbfbfb;padding:8px;border-radius:8px;font-family:monospace}
    .svgwrap{background:linear-gradient(180deg,#fff,#f8fafc);display:flex;align-items:center;justify-content:center;padding:12px;border-radius:8px}
    .graph{background:#fff;border-radius:8px;padding:8px;margin-top:8px}
    footer{margin-top:14px;color:var(--muted);font-size:13px}
    @media (max-width:1100px){.grid{grid-template-columns:1fr}} 
  </style>
</head>
<body>
  <div class="container">
    <h1 style="margin:0 0 6px 0">Simulador de Ascensor Manual — Avanzado</h1>
    <p class="small">Incluye: fricción constante (τ_f), gráficos en tiempo real (energía y altura) y animación mejorada (cuerda enrollándose, poleas).</p>

    <div class="grid">
      <!-- Controls -->
      <div class="card">
        <h3 style="margin:0 0 6px 0">Parámetros</h3>
        <label>Masa cabina m (kg)</label>
        <input id="m" type="number" value="200" step="1" />

        <label>Número de ramales n</label>
        <input id="n" type="number" value="2" min="1" step="1" />

        <label>Radio tambor r (m)</label>
        <input id="r" type="number" value="0.2" step="0.01" />

        <label>Radio manivela L_h (m)</label>
        <input id="Lh" type="number" value="0.5" step="0.01" />

        <label>Momento de inercia tambor I (kg·m²)</label>
        <input id="I" type="number" value="5" step="0.1" />

        <label>Gravedad g (m/s²)</label>
        <input id="g" type="number" value="9.8" step="0.01" />

        <label>Aceleración deseada de la cabina a (m/s²) (positiva hacia arriba)</label>
        <input id="a" type="number" value="0.5" step="0.01" />

        <label>Tiempo de aceleración t (s)</label>
        <input id="tSim" type="number" value="2" step="0.1" />

        <label>Torque de fricción (τ_f) constante (N·m) — opción A</label>
        <input id="tau_f" type="number" value="10" step="0.1" />

        <div style="margin-top:12px;display:flex;gap:8px">
          <button id="btnSim">Simular</button>
          <button id="btnPause" class="secondary">Pausa</button>
          <button id="btnReset" class="secondary">Reset</button>
        </div>

        <div class="small" style="margin-top:10px">La fricción τ_f se resta como torque adicional constante: W_pérdida = τ_f · θ. Los gráficos actualizan en tiempo real.</div>
      </div>

      <!-- Visual -->
      <div class="card svgwrap" style="flex-direction:column">
        <h3 style="margin:0 0 8px 0">Vista mecánica</h3>
        <svg id="scene" width="500" height="420" viewBox="0 0 500 420"></svg>
        <div style="display:flex;gap:12px;align-items:center;margin-top:8px;width:100%;justify-content:space-between">
          <div class="small" id="tNow">Tiempo: 0.00 s</div>
          <div class="note">Ángulo manivela: <span id="angleDisplay">0.00</span> rad</div>
        </div>

        <div class="graph" style="width:100%;display:flex;gap:8px">
          <canvas id="graphEnergy" width="320" height="120" style="border-radius:6px;background:#fafafa"></canvas>
          <canvas id="graphHeight" width="320" height="120" style="border-radius:6px;background:#fafafa"></canvas>
        </div>
      </div>

      <!-- Results -->
      <div class="card">
        <h3 style="margin:0 0 6px 0">Resultados (física y energía)</h3>
        <div id="resultsGrid" class="results"></div>
        <div style="margin-top:10px" class="small">Comprobación: W_in = ∫ τ_h ω dt, pérdidas = τ_f θ. Esta versión calcula todo numéricamente en pequeños pasos dt.</div>
      </div>
    </div>

    <footer>Si quieres exportar los datos (CSV) o descargar imágenes de los gráficos, lo agrego en la próxima actualización.</footer>
  </div>

  <script>
    // Utils
    const el = id => document.getElementById(id);
    const num = id => { const v = parseFloat(el(id).value); return isNaN(v)?0:v };

    // Physics compute single-step closed forms (used for initial calc)
    function nominalValues(params){
      const {m,n,r,Lh,I,g,a} = params;
      const T1_static = (m*g)/n;
      const tau_static = T1_static * r;
      const Fh_static = tau_static / Lh;

      const T1_dyn = (m*(g+a))/n;
      const alpha = (n*a)/r;
      const tau_dyn = I*alpha + T1_dyn * r; // without friction
      const Fh_dyn = tau_dyn / Lh;

      return {T1_static,tau_static,Fh_static,T1_dyn,alpha,tau_dyn,Fh_dyn};
    }

    // SVG scene params
    const svg = document.getElementById('scene');
    const W = 500, H = 420;
    const drumX = 100, drumY = 80;
    const manivelaX = 420, manivelaY = 260;
    const cabinBaseY = 320; // pixel for h=0
    const scale = 60; // px per meter

    function clearSVG(){ while(svg.firstChild) svg.removeChild(svg.firstChild); }

    function drawScene(n, dh_now, simState){
      clearSVG();
      // support
      svg.appendChild(sv('rect',{x:drumX-12,y:drumY-24,width:24,height:48,rx:4,fill:'#333'}));
      // drum
      svg.appendChild(sv('circle',{cx:drumX,cy:drumY,r:26,stroke:'#444','stroke-width':4,fill:'#eee'}));
      svg.appendChild(sv('rect',{x:drumX-6,y:drumY-30,width:12,height:60,fill:'#bbb'}));

      // top moving pulley (to illustrate polipasto)
      const topPulleyX = drumX + 60, topPulleyY = drumY;
      svg.appendChild(sv('circle',{cx:topPulleyX,cy:topPulleyY,r:18,stroke:'#666','stroke-width':3,fill:'#fafafa'}));
      svg.appendChild(sv('circle',{cx:topPulleyX,cy:topPulleyY,r:6,fill:'#999'}));

      // manivela and handle
      svg.appendChild(sv('circle',{cx:manivelaX,cy:manivelaY,r:36,stroke:'#333','stroke-width':3,fill:'#fff'}));
      const armLen = 48;
      const angle = simState.theta; // use θ as total angle
      const armX = manivelaX + armLen * Math.cos(angle);
      const armY = manivelaY + armLen * Math.sin(angle);
      svg.appendChild(sv('line',{x1:manivelaX,y1:manivelaY,x2:armX,y2:armY,stroke:'#111','stroke-width':5,'stroke-linecap':'round'}));
      svg.appendChild(sv('circle',{cx:armX,cy:armY,r:7,fill:'#111'}));

      // rope from drum to top pulley
      svg.appendChild(sv('line',{x1:drumX+26,y1:drumY,x2:topPulleyX-18,y2:topPulleyY,stroke:'#222','stroke-width':2}));

      // ramales from top pulley to cabina
      const cabinYPixel = cabinBaseY - dh_now*scale;
      for(let i=0;i<n;i++){
        const offset = (i - (n-1)/2) * 12;
        // show rope segment
        const line = sv('line',{x1:topPulleyX+offset,y1:topPulleyY+18,x2:drumX+offset,y2:cabinYPixel-30,stroke:'#222','stroke-width':Math.min(6,1+simState.T1/400)});
        svg.appendChild(line);
      }

      // cabin
      svg.appendChild(sv('rect',{x:drumX-40,y:cabinYPixel-30,width:180,height:60,rx:10,fill:'#f3f4f6',stroke:'#111'}));
      svg.appendChild(sv('text',{x:drumX+50,y:cabinYPixel, 'text-anchor':'middle','dominant-baseline':'middle','font-size':14,fill:'#111'}, 'Cabina'));

      // show tension numeric near cable
      svg.appendChild(sv('text',{x:topPulleyX+80,y:drumY-10,'font-size':12,fill:'#111'}, `T1=${simState.T1.toFixed(1)} N`));
      svg.appendChild(sv('text',{x:topPulleyX+80,y:drumY+8,'font-size':12,fill:'#111'}, `τ_f=${simState.tau_f.toFixed(2)} N·m`));

      // ground
      svg.appendChild(sv('line',{x1:0,y1:cabinBaseY+48,x2:W,y2:cabinBaseY+48,stroke:'#999','stroke-dasharray':'4 4'}));
    }

    function sv(tag, attrs, txt){ const n = document.createElementNS('http://www.w3.org/2000/svg', tag); if(attrs) for(const k in attrs) n.setAttribute(k, attrs[k]); if(txt) n.textContent = txt; return n }

    // Graph utilities (simple plot on canvas)
    function plotCanvas(ctx, dataX, dataY, opts){
      const w = ctx.canvas.width, h = ctx.canvas.height; ctx.clearRect(0,0,w,h);
      // axes
      ctx.strokeStyle='#ddd'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(40,8); ctx.lineTo(40,h-18); ctx.lineTo(w-8,h-18); ctx.stroke();
      // labels
      ctx.fillStyle='#666'; ctx.font='11px Arial'; ctx.fillText(opts.yLabel||'',8,18); ctx.fillText('t (s)',w-40,h-6);
      // map data
      const xmin = 0, xmax = Math.max(1, dataX[dataX.length-1]||1);
      const ymin = Math.min(...dataY), ymax = Math.max(...dataY);
      const pad = 8; const plotW = w-56, plotH = h-36;
      // y ticks
      ctx.fillStyle='#999'; ctx.font='10px Arial'; ctx.fillText(ymin.toFixed(1),6,h-20); ctx.fillText(ymax.toFixed(1),6,16);
      // polyline
      ctx.strokeStyle = opts.color || '#0b63d6'; ctx.lineWidth=2; ctx.beginPath();
      for(let i=0;i<dataX.length;i++){ const x = 40 + (dataX[i]-xmin)/(xmax-xmin+1e-9)*plotW; const y = 8 + (1-(dataY[i]-ymin)/(ymax-ymin+1e-9))*plotH; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
      ctx.stroke();
    }

    // --- Simulation numeric integrator (constant requested acceleration a, compute required τ_h including τ_f)
    let raf=null; let start=0; let running=false; let paused=false;
    let simData = {time:[], energyIn:[], energyK:[], energyU:[], height:[], T1:[]};

    function simulateStart(){ if(running) return; paused=false; running=true; simData = {time:[], energyIn:[], energyK:[], energyU:[], height:[], T1:[]}; start = null; cancelAnimationFrame(raf); raf = requestAnimationFrame(step); }
    function simulatePause(){ paused = !paused; }
    function simulateReset(){ running=false; paused=false; cancelAnimationFrame(raf); start=null; simData = {time:[], energyIn:[], energyK:[], energyU:[], height:[], T1:[]}; renderInitial(); }

    function step(ts){
      if(!start) start = ts; if(paused){ raf = requestAnimationFrame(step); return; }
      const elapsed = (ts-start)/1000; const params = {m:num('m'), n: Math.max(1,Math.floor(num('n'))), r:num('r'), Lh:num('Lh'), I:num('I'), g:num('g'), a:num('a'), t:num('tSim'), tau_f:num('tau_f')};
      const tEnd = params.t;
      // analytic kinematics assuming constant acceleration a
      const tNow = Math.min(elapsed, tEnd);
      const dh = 0.5 * params.a * tNow * tNow; // m
      const v = params.a * tNow; // m/s
      const omega = (v * params.n) / params.r; // rad/s
      const alpha = (params.n * params.a) / params.r; // rad/s^2
      const theta = 0.5 * alpha * tNow * tNow; // rad

      // tensions and torques
      const T1 = (params.m * (params.g + params.a)) / params.n; // N
      const tau_needed = params.I * alpha + T1 * params.r; // without friction
      const tau_h = tau_needed + params.tau_f; // human torque must overcome friction too

      // Energies: integrate numerically using instantaneous power P = τ_h * ω
      // We'll approximate dW = τ_h * ω * dt, but here we can compute accumulated analytically since α constant
      // Simpler: record instantaneous quantities and do trapezoid integration externally.

      // record
      simData.time.push(tNow);
      // instantaneous energies
      const K_cab = 0.5 * params.m * v * v;
      const K_tamb = 0.5 * params.I * omega * omega;
      const U = params.m * params.g * dh;
      simData.energyK.push(K_cab + K_tamb);
      simData.energyU.push(U);
      // approximate W_in by numerical integration of τ_h*ω
      const lastIndex = simData.time.length - 1;
      if(lastIndex === 0){ simData.energyIn.push(tau_h * omega * 0 * 0 + 0); } else {
        // trapezoid from previous step
        const dt = simData.time[lastIndex] - simData.time[lastIndex-1];
        // previous τ_h and ω approximated from previous recorded values
        // compute prev values
        const tPrev = simData.time[lastIndex-1];
        const vPrev = params.a * tPrev; const omegaPrev = (vPrev * params.n) / params.r; const alphaPrev = alpha; const thetaPrev = 0.5 * alphaPrev * tPrev * tPrev;
        const T1Prev = (params.m * (params.g + params.a)) / params.n;
        const tauNeededPrev = params.I * alphaPrev + T1Prev * params.r; const tau_hPrev = tauNeededPrev + params.tau_f;
        const Pprev = tau_hPrev * omegaPrev; const Pnow = tau_h * omega;
        const Wprev = simData.energyIn[lastIndex-1] || 0;
        simData.energyIn.push(Wprev + 0.5 * (Pprev + Pnow) * dt);
      }

      simData.height.push(dh);
      simData.T1.push(T1);

      // update UI numbers
      el('tNow').textContent = 'Tiempo: ' + tNow.toFixed(2) + ' s';

      // draw scene
      const simState = {T1: T1, tau_f: params.tau_f, theta: theta};
      drawScene(params.n, dh, simState);
      el('angleDisplay').textContent = theta.toFixed(3);

      // update graphs
      drawGraphs(simData);

      if(elapsed < tEnd){ raf = requestAnimationFrame(step); } else { running=false; cancelAnimationFrame(raf); renderFinalResults(params, simData); }
    }

    function drawGraphs(data){
      const ctxE = document.getElementById('graphEnergy').getContext('2d');
      const ctxH = document.getElementById('graphHeight').getContext('2d');
      // Energy plot: energyIn vs time; K and U stacked? We'll plot three lines: W_in, K_total, U
      const times = data.time;
      const Wins = data.energyIn;
      const Ktot = data.energyK;
      const U = data.energyU;
      if(times.length < 2){ ctxE.clearRect(0,0,320,120); ctxH.clearRect(0,0,320,120); return; }
      plotCanvas(ctxE, times, Wins, {yLabel:'W_in (J)', color:'#0b63d6'});
      // overlay K
      overlayLine(ctxE, times, Ktot, '#16a34a');
      overlayLine(ctxE, times, U, '#f59e0b');
      plotCanvas(ctxH, times, data.height, {yLabel:'h (m)', color:'#0b63d6'});
    }

    function overlayLine(ctx, dataX, dataY, color){ const w = ctx.canvas.width, h = ctx.canvas.height; const xmin=0, xmax=Math.max(1,dataX[dataX.length-1]); const ymin=Math.min(...dataY), ymax=Math.max(...dataY); const plotW=w-56, plotH=h-36; ctx.strokeStyle=color; ctx.lineWidth=2; ctx.beginPath(); for(let i=0;i<dataX.length;i++){ const x = 40 + (dataX[i]-xmin)/(xmax-xmin+1e-9)*plotW; const y = 8 + (1-(dataY[i]-ymin)/(ymax-ymin+1e-9))*plotH; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.stroke(); }

    // final results (numeric)
    function renderFinalResults(params, data){
      // take last values
      const idx = data.time.length - 1;
      const W_in = data.energyIn[idx] || 0;
      const Ktot = data.energyK[idx] || 0;
      const U = data.energyU[idx] || 0;
      const lastT1 = data.T1[idx] || 0;
      const theta = 0.5 * ((params.n * params.a)/params.r) * params.t * params.t;
      const W_loss = params.tau_f * theta;

      const grid = el('resultsGrid'); grid.innerHTML = '';
      const rows = [
        ['Tensión final T₁', lastT1.toFixed(2)+' N'],
        ['Trabajo total W_in', W_in.toFixed(2)+' J'],
        ['Trabajo perdido (fricción) W_loss', W_loss.toFixed(2)+' J'],
        ['Energía cinética total', Ktot.toFixed(2)+' J'],
        ['Energía potencial ΔU', U.toFixed(2)+' J'],
        ['Comprobación: W_in ?= K + U + pérdidas', `${W_in.toFixed(2)} ≈ ${(Ktot+U+W_loss).toFixed(2)} J`]
      ];
      for(const [k,v] of rows){ const d=document.createElement('div'); d.className='result'; d.innerHTML = `<div style="font-size:12px;color:#666">${k}</div><div style="margin-top:6px">${v}</div>`; grid.appendChild(d);} 
    }

    // helper initial render
    function renderInitial(){ const params = {m:num('m'), n: Math.max(1,Math.floor(num('n'))), r:num('r'), Lh:num('Lh'), I:num('I'), g:num('g'), a:num('a'), t:num('tSim')}; const nominal = nominalValues(params);
      const simState = {T1: nominal.T1_dyn, tau_f: num('tau_f'), theta:0}; drawScene(params.n, 0, simState); drawGraphs({time:[],energyIn:[],energyK:[],energyU:[],height:[]}); renderTempResults(nominal);
    }

    function renderTempResults(nominal){ const grid = el('resultsGrid'); grid.innerHTML=''; const rows = [ ['Tensión (estática) T₁', nominal.T1_static.toFixed(2)+' N'], ['Torque (estático) τ', nominal.tau_static.toFixed(2)+' N·m'], ['Fuerza humana (estática) F_h', nominal.Fh_static.toFixed(2)+' N'], ['Tensión (dinámica) T₁', nominal.T1_dyn.toFixed(2)+' N'], ['α (rad/s²)', nominal.alpha.toFixed(3)+' rad/s²'], ['Torque (sin fricción) τ (dinámico)', nominal.tau_dyn.toFixed(2)+' N·m'] ]; for(const [k,v] of rows){ const d=document.createElement('div'); d.className='result'; d.innerHTML = `<div style="font-size:12px;color:#666">${k}</div><div style="margin-top:6px">${v}</div>`; grid.appendChild(d);} }

    // buttons
    el('btnSim').addEventListener('click', ()=> simulateStart());
    el('btnPause').addEventListener('click', ()=> { simulatePause(); el('btnPause').textContent = el('btnPause').textContent === 'Pausa' ? 'Continuar' : 'Pausa'; });
    el('btnReset').addEventListener('click', ()=> { simulateReset(); });

    // init
    renderInitial();

  </script>
</body>
</html>
